// © LINK2035

//@version=6
indicator("WhichWay [by LINK2035]", overlay=true)


isShowPrevSSLBSL = input.bool(defval=false, title='Show previous SSL/BSL')
isShowBlBrTrend = input.bool(defval=true, title='Show Bullish/Bearish trend')


var float ssl_bl = 0.0
var float bsl_bl = 0.0
var float int_ssl_bl = 0.0
var float int_bsl_br = 0.0
var int ssl_index = 0
var int bsl_index = 0
var int int_ssl_index = 0
var int int_bsl_index = 0
var bool isConf_bl = false
var bool isBreak_bl = false
var bool isBull = true
var bool isBear = false
var bool isWeakOF = false

var line[] ssl_array = array.new_line()
var line[] bsl_array = array.new_line()


// The method finds the nearest BSL fractal
detector_bsl_last_fractal() =>
    bsl_high = 0.0
    bsl_index_ = 0
    for i = 0 to bar_index by 1
        if high[i+1] > high[i+2] and high[i+1] > high[i]
            bsl_high := high[i+1]
            bsl_index_ := bar_index - (i+1)
            break
    [bsl_high, bsl_index_]

// The method finds the nearest SSL fractal
detector_ssl_last_fractal() =>
    ssl_low = 0.0
    ssl_index_ = 0
    for i = 0 to bar_index by 1
        if low[i+1] < low[i+2] and low[i+1] < low[i]
            ssl_low := low[i+1]
            ssl_index_ := bar_index - (i+1)
            break
    [ssl_low, ssl_index_]


// if the OF is ascending
if isBull
    // if the SSL does not exist yet, we find it
    if ssl_bl <= 0.0 and low[1] < low[2] and low[1] < low
        ssl_bl := low[1]
        ssl_index := bar_index[1]
        l = line.new(ssl_index, ssl_bl, bar_index, ssl_bl, extend=extend.right, color=color.green, width=1)
        array.push(ssl_array, l)


    // if the SSL exists but the BSL does not yet, we will update the SSL if it goes below the previous one
    if ssl_bl > 0.0 and bsl_bl <= 0.0 and low[1] < low[2] and low[1] < low and low[1] < ssl_bl
        ssl_bl := low[1]
        ssl_index := bar_index[1]
        if array.size(ssl_array) > 0
            line.set_xy1(array.last(ssl_array), ssl_index, ssl_bl)
            line.set_xy2(array.last(ssl_array), bar_index, ssl_bl)
            line.set_extend(array.last(ssl_array), extend.right)

    // if the BSL does not exist yet but the SSL already does, we find the BSL
    if bsl_bl <= 0.0 and ssl_bl > 0.0 and high[1] > high[2] and high[1] > high
        bsl_bl := high[1]
        bsl_index := bar_index[1]
        l = line.new(bsl_index, bsl_bl, bar_index, bsl_bl, extend=extend.right, color=color.maroon, width=1)
        array.push(bsl_array, l)

    // if the BSL exists but the INT_SSL does not yet, we will update the BSL if it forms higher
    if bsl_bl > 0.0 and int_ssl_bl <= 0.0 and high[1] > high[2] and high[1] > high and high[1] > bsl_bl
        bsl_bl := high[1]
        bsl_index := bar_index[1]
        if array.size(bsl_array) > 0
            line.set_xy1(array.last(bsl_array), bsl_index, bsl_bl)
            line.set_xy2(array.last(bsl_array), bar_index, bsl_bl)
            line.set_extend(array.last(bsl_array), extend.right)

    
// if the OF is descending
if isBear
    // if the BSL does not exist yet, we find it
    if bsl_bl <= 0.0 and high[1] > high[2] and high[1] > high
        bsl_bl := 0.0
        bsl_index := bar_index[1]
        l = line.new(bsl_index, bsl_bl, bar_index, bsl_bl, extend=extend.right, color=color.maroon, width=1)
        array.push(bsl_array, l)
    
    // if the BSL exists but the SSL does not yet, we will update the BSL if it forms higher
    if bsl_bl > 0.0 and ssl_bl <= 0.0 and high[1] > high[2] and high[1] > high and high[1] > bsl_bl
        bsl_bl := high[1]
        bsl_index := bar_index[1]
        if array.size(bsl_array) > 0
            line.set_xy1(array.last(bsl_array), bsl_index, bsl_bl)
            line.set_xy2(array.last(bsl_array), bar_index, bsl_bl)
            line.set_extend(array.last(bsl_array), extend.right)
    
    // if the SSL does not exist yet but the BSL already does, then we find the SSL
    if ssl_bl <= 0.0 and bsl_bl > 0.0 and low[1] < low[2] and low[1] < low
        ssl_bl := low[1]
        ssl_index := bar_index[1]
        l = line.new(ssl_index, ssl_bl, bar_index, ssl_bl, extend=extend.right, color=color.green, width=1)
        array.push(ssl_array, l)

    // if the SSL exists but the INT_BSL does not yet, we will update the SSL if it forms lower
    if ssl_bl > 0.0 and int_bsl_br <= 0.0 and low[1] < low[2] and low[1] < low and low[1] < ssl_bl
        ssl_bl := low[1]
        ssl_index := bar_index[1]
        if array.size(ssl_array) > 0
            line.set_xy1(array.last(ssl_array), ssl_index, ssl_bl)
            line.set_xy2(array.last(ssl_array), bar_index, ssl_bl)
            line.set_extend(array.last(ssl_array), extend.right)

// if the OF is ascending
if isBull
    // if the BSL exists, we find the internal SSL if it does not exist
    if bsl_bl > 0.0 and int_ssl_bl <= 0.0 and low[1] < low[2] and low[1] < low
        int_ssl_bl := low[1]
        int_ssl_index := bar_index[1]

    // if the INT_SSL already exists, it will be updated if it is lower than the previous one
    if int_ssl_bl > 0.0 and low[1] < low[2] and low[1] < low and low[1] < int_ssl_bl
        int_ssl_bl := low[1]
        int_ssl_index := bar_index[1]

// if the OF is descending
if isBear
    // if the SSL exists but the INT_BSL does not yet, we find it
    if ssl_bl > 0.0 and int_bsl_br <= 0.0 and high[1] > high[2] and high[1] > high
        int_bsl_br := high[1]
        int_bsl_index := bar_index[1]

    // if the INT_BSL already exists, it will be updated if it is higher than the previous one
    if int_bsl_br > 0 and high[1] > high[2] and high[1] > high and high[1] > int_bsl_br
        int_bsl_br := high[1]
        int_bsl_index := bar_index[1]

// if the OF is ascending
if isBull
    if ssl_bl > 0.0 and int_ssl_bl > 0.0 
        // check if there was a candle that broke the impulse and closed beyond the SSL
        if not isBreak_bl and close < ssl_bl
            isBreak_bl := true
            isWeakOF := false
            if array.size(ssl_array) > 0 and array.size(bsl_array) > 0
                // update the new X2 points, set lines to not continue, and remove from the array
                line.set_x2(array.last(ssl_array), bar_index)
                line.set_extend(array.last(ssl_array), extend.none)
                line.set_x2(array.last(bsl_array), bar_index)
                line.set_extend(array.last(bsl_array), extend.none)
        // if such a candle exists, we set a new SSL and keep the BSL
        if isBreak_bl and low[1] < low[2] and low[1] < low
            ssl_bl := low[1]
            int_ssl_bl := 0.0
            [bsl_bl_, bsl_index_] = detector_bsl_last_fractal()
            bsl_bl := bsl_bl_
            bsl_index := bsl_index_
            isBreak_bl := false
            isBull := false
            isBear := true
            if not isShowPrevSSLBSL
                line.delete(array.pop(ssl_array))
            else
                array.pop(ssl_array)
            l = line.new(bar_index[1], ssl_bl, bar_index, ssl_bl, extend=extend.right, color=color.green, width=1)
            array.push(ssl_array, l)
            if not isShowPrevSSLBSL
                line.delete(array.pop(bsl_array))
            else
                array.pop(bsl_array)
            l := line.new(bsl_index, bsl_bl, bar_index, bsl_bl, extend=extend.right, color=color.maroon, width=1)
            array.push(bsl_array, l)

    if bsl_bl > 0.0 and int_ssl_bl > 0.0
        // check if there was a candle that updated the impulse and closed beyond the BSL
        if not isConf_bl and close > bsl_bl
            isConf_bl := true
            isWeakOF := false
            // if the arrays are not empty
            if array.size(ssl_array) > 0 and array.size(bsl_array) > 0
                // update the new X2 points, set lines to not continue, and remove from the array
                line.set_x2(array.last(ssl_array), bar_index)
                line.set_extend(array.last(ssl_array), extend.none)
                line.set_x2(array.last(bsl_array), bar_index)
                line.set_extend(array.last(bsl_array), extend.none)
        // if such a candle exists, we update both BSL and SSL
        if isConf_bl and high[1] > high[2] and high[1] > high
            bsl_bl := high[1]
            ssl_bl := int_ssl_bl
            ssl_index := int_ssl_index
            int_ssl_bl := 0.0
            int_ssl_index := 0
            isConf_bl := false
            if not isShowPrevSSLBSL
                line.delete(array.pop(ssl_array))
            else
                array.pop(ssl_array)
            l = line.new(ssl_index, ssl_bl, bar_index, ssl_bl, extend=extend.right, color=color.green, width=1)
            array.push(ssl_array, l)
            if not isShowPrevSSLBSL
                line.delete(array.pop(bsl_array))
            else
                array.pop(bsl_array)
            l := line.new(bar_index[1], bsl_bl, bar_index, bsl_bl, extend=extend.right, color=color.maroon, width=1)
            array.push(bsl_array, l)

// if the OF is descending
if isBear
    if bsl_bl > 0.0 and int_bsl_br > 0.0
        // check if there was a candle that updated the impulse and closed beyond the SSL
        if not isBreak_bl and close > bsl_bl
            isBreak_bl := true
            isWeakOF := false
            if array.size(ssl_array) > 0 and array.size(bsl_array) > 0
                // update the new X2 points, set lines to not continue, and remove from the array
                line.set_x2(array.last(ssl_array), bar_index)
                line.set_extend(array.last(ssl_array), extend.none)
                line.set_x2(array.last(bsl_array), bar_index)
                line.set_extend(array.last(bsl_array), extend.none)
        // if such a candle exists, we set a new BSL and keep the SSL
        if isBreak_bl and high[1] > high[2] and high[1] > high
            bsl_bl := high[1] // 0.0 // int_bsl_br
            int_bsl_br := 0.0
            [ssl_bl_, ssl_index_] = detector_ssl_last_fractal()
            ssl_bl := ssl_bl_
            ssl_index := ssl_index_
            isBreak_bl := false
            isBear := false
            isBull := true
            if not isShowPrevSSLBSL
                line.delete(array.pop(ssl_array))
            else
                array.pop(ssl_array)
            l = line.new(ssl_index, ssl_bl, bar_index, ssl_bl, extend=extend.right, color=color.green, width=1)
            array.push(ssl_array, l)
            if not isShowPrevSSLBSL
                line.delete(array.pop(bsl_array))
            else
                array.pop(bsl_array)
            l := line.new(bar_index[1], bsl_bl, bar_index, bsl_bl, extend=extend.right, color=color.maroon, width=1)
            array.push(bsl_array, l)
        
    if ssl_bl > 0.0 and int_bsl_br > 0.0
        // check if there was a candle that updated the impulse and closed beyond the SSL
        if not isConf_bl and close < ssl_bl
            isConf_bl := true
            isWeakOF := false
            if array.size(ssl_array) > 0 and array.size(bsl_array) > 0
                // update the new X2 points, set lines to not continue, and remove from the array
                line.set_x2(array.last(ssl_array), bar_index)
                line.set_extend(array.last(ssl_array), extend.none)
                line.set_x2(array.last(bsl_array), bar_index)
                line.set_extend(array.last(bsl_array), extend.none)
        // if such a candle exists, we update both SSL and BSL
        if isConf_bl and low[1] < low[2] and low[1] < low
            ssl_bl := low[1]
            bsl_bl := int_bsl_br
            bsl_index := int_bsl_index
            int_bsl_br := 0.0
            int_bsl_index := 0
            isConf_bl := false
            if not isShowPrevSSLBSL
                line.delete(array.pop(ssl_array))
            else
                array.pop(ssl_array)
            l = line.new(bar_index[1], ssl_bl, bar_index, ssl_bl, extend=extend.right, color=color.green, width=1)
            array.push(ssl_array, l)
            if not isShowPrevSSLBSL
                line.delete(array.pop(bsl_array))
            else
                array.pop(bsl_array)
            l := line.new(bsl_index, bsl_bl, bar_index, bsl_bl, extend=extend.right, color=color.maroon, width=1)
            array.push(bsl_array, l)

if array.size(ssl_array) > 0
    line.set_extend(array.last(ssl_array), extend.none)
    line.set_x2(array.last(ssl_array), bar_index)
if array.size(bsl_array) > 0
    line.set_extend(array.last(bsl_array), extend.none)
    line.set_x2(array.last(bsl_array), bar_index)

ssl_label = label.new(x=bar_index + 5, y=ssl_bl, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, color=color.green,
 text='SSL ' + str.tostring(ssl_bl, format.mintick), textcolor=color.white, textalign=text.align_center, size=size.small)
label.delete(ssl_label[1])

bsl_label = label.new(x=bar_index + 5, y=bsl_bl, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, color=color.maroon,
 text='BSL ' + str.tostring(bsl_bl, format.mintick), textcolor=color.white, textalign=text.align_center, size=size.small)
label.delete(bsl_label[1])


// ====================
// FVG DETECTOR
// ====================

var box[] fvg_bl_array = array.new_box()
var box[] fvg_br_array = array.new_box()

// if the OF is ascending
if isBull
    // if the SSL exists
    if ssl_bl > 0.0
        // if the impulse is updating, clear the entire array so that elements don’t extend into the next impulse
        if isConf_bl and not isConf_bl[1]
            array.clear(fvg_bl_array)
        // finds the ascending FVG
        if barstate.isconfirmed and low > high[2]
            b = box.new(bar_index, low, bar_index[2], high[2], 
             border_color=color.new(color.black, 100), border_width=0, bgcolor=color.new(color.green, 85), 
             text='fvg+', text_color=color.new(color.green, 50), text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
            array.push(fvg_bl_array, b)
            // ensures the array does not contain more than 50 elements
            if array.size(fvg_bl_array) > 50
                box.delete(array.shift(fvg_bl_array))

    // if there is anything in the array
    if array.size(fvg_bl_array) > 0
        for i = 0 to array.size(fvg_bl_array) - 1 by 1
            // extend the FVG if it is not invalidated
            if close > box.get_bottom(array.get(fvg_bl_array, i))
                box.set_right(array.get(fvg_bl_array, i), bar_index)
            // if the FVG is invalidated, remove it from the array
            else if close < box.get_bottom(array.get(fvg_bl_array, i))
                box.set_bgcolor(array.get(fvg_bl_array, i), color=color.new(color.gray, 85))
                box.set_text_color(array.get(fvg_bl_array, i), text_color=color.new(color.gray, 50))
                box.set_text(array.get(fvg_bl_array, i), text='inv. fvg+')
                array.remove(fvg_bl_array, i)
                // if this is a new impulse and the nearest zone has not been 
                // invalidated yet, isWeak will be false, and here, after the 
                // zone is invalidated, it indicates that isWeakOF is true, 
                // since the nearest zone was invalidated
                if not isWeakOF
                    isWeakOF := true
                    label.new(bar_index, high, 'Weak bullish \n & \n local short', color=color.new(color.maroon, 50), textcolor=color.new(color.white, 50),
                     textalign=text.align_center, size=size.small, style=label.style_label_down)

// if the OF is descending
if isBear
    // if the BSL exists
    if bsl_bl > 0.0
        // if the impulse is updating, clear the entire array so that elements don’t extend into the next impulse
        if isConf_bl and not isConf_bl[1]
            array.clear(fvg_br_array)
        // finds the descending FVG
        if barstate.isconfirmed and high < low[2]
            b = box.new(bar_index[2], low[2], bar_index, high, 
             border_color=color.new(color.black, 100), border_width=0, bgcolor=color.new(color.red, 85), 
             text='fvg-', text_color=color.new(color.red, 50), text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
            array.push(fvg_br_array, b)
            // ensures the array does not contain more than 50 elements
            if array.size(fvg_br_array) > 50
                box.delete(array.shift(fvg_br_array))

    // if there is anything in the array
    if array.size(fvg_br_array) > 0
        for i = 0 to array.size(fvg_br_array) - 1 by 1
            // extend the FVG if it is not invalidated
            if close < box.get_top(array.get(fvg_br_array, i))
                box.set_right(array.get(fvg_br_array, i), bar_index)
            // if the FVG is invalidated, remove it from the array
            else if close > box.get_top(array.get(fvg_br_array, i))
                box.set_bgcolor(array.get(fvg_br_array, i), color=color.new(color.gray, 85))
                box.set_text_color(array.get(fvg_br_array, i), text_color=color.new(color.gray, 50))
                box.set_text(array.get(fvg_br_array, i), text='inv. fvg-')
                array.remove(fvg_br_array, i)
                // if this is a new impulse and the nearest zone has not been 
                // invalidated yet, isWeak will be false, and here, after the 
                // zone is invalidated, it indicates that isWeakOF is true, 
                // since the nearest zone was invalidated
                if not isWeakOF
                    isWeakOF := true
                    label.new(bar_index, low, 'Weak bearish \n & \n local long', color=color.new(color.green, 50), textcolor=color.new(color.white, 50),
                     textalign=text.align_center, size=size.small, style=label.style_label_up)



p1 = plot(isShowBlBrTrend ? (array.size(ssl_array) > 0 ? line.get_y1(array.last(ssl_array)) : na) : na, color=color.new(color.gray, 100), style=plot.style_linebr)
p2 = plot(isShowBlBrTrend ? (array.size(bsl_array) > 0 ? line.get_y1(array.last(bsl_array)) : na) : na, color=color.new(color.gray, 100), style=plot.style_linebr)
fill(p1, p2, color=isBull ? color.new(color.green, 90) : color.new(color.red, 90))
